// Assuming Kr[i] is a list of lists so that Kr0_(i) == Kr[0][i]
// The function takes in input Beta (specs), i the number of the round
// Kr, the shift keys and Km, the mixing keys 
// (maybe Km and Kr could be replaced by global variables)
 
QBAR := function(Beta,i,Kr,Km)

	A := [Beta[1..32]];
	B := [Beta[33..64]];
	C := [Beta[65..96]];
	D := [Beta[97..128]];

	F := GF(2,32);

	D := ElementToSequence(F!D + F!f1(A,Kr[3][i],Km[3][i]));
	A := ElementToSequence(F!A + F!f3(B,Kr[2][i],Km[2][i]));
	B := ElementToSequence(F!B + F!f2(C,Kr[1][i],Km[1][i]));
	C := ElementToSequence(F!C + F!f1(D,Kr[0][i],Km[0][i])); 

	return (A cat B cat C cat D); 

end function;

// takes a sequence of 32 bits and converts it into an integer

sequenceToInt := function(Sequence)

	integer := 0;
	
	for i in [1..#Sequence] do
		
		integer +:= Sequence[i]*2^(i-1);
		
	end for;
	
	return integer;

end function;

intTo32Sequence := function(integer)

	Sequence := [];
	integer := Integers()!integer;
	
	for i in [1..32] do
		r := integer mod 2;
		integer := Integers()!((integer - r)/2);

		Sequence cat:= [r];
	end for;

	return Sequence;

end function;


// f1, f2, f3 as defined in CAST-128 specification

f1 := function(D,Kmi,Kri)

	F := GF(2,32);
	
	I := ()
	

end function;